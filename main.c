#include <snes.h>
#include <string.h>

extern char patternsbg1, patternsbg1_end;
extern char patternsbg2, patternsbg2_end;
extern char palettebg1, palettebg1_end;
extern char palettebg2, palettebg2_end;
extern char mapbg1, mapbg1_end;
extern char mapbg2, mapbg2_end;

extern char gfxpsrite, gfxpsrite_end;
extern char palsprite, palsprite_end;

u8 pada,padb,padx;
u16 pad0,pad1;

u16 p1_pos_x = 50;
u16 p1_pos_y = 50;
u16 p2_pos_x = 150;
u16 p2_pos_y = 150;


// Single HDMA table for both windows's left/right positions
// HDMA Mode 4 : 4 bytes transfered at once on 4 consecutive registers ($2126-$2129)
u8 window_positions_table[]=
{
	// Lines count, Window 1 Left, Window 1 Right, Window 2 Left, Window 2 Right
	1, 0xff, 0x0, 0xff, 0x0,	// Disabled at first

	0x80 | 60,					// 60 lines

	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,

	0x80 | 60,					// 60 lines

	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,

	0x80 | 60,					// 60 lines

	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,

	0x80 | 60,					// 60 lines

	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	
	1, 0xff, 0x0, 0xff, 0x0,
	0
};


/*! \fn  setModeHdmaWindow(u8 bgrnd, u8* hdmatableL,u8* hdmatableR)
    \brief Do a window  effect on screen. Use HDMA Channels 4 & 5.
    \param bgrnd background for the windows effect  (value MSWIN_BG1..MSWIN_BG4)
    \param bgrndmask background mask (inside, outside) for the windows effect  (value MSWIN1_BG13MSKIN..MSWIN1_BG13MSKIN)
    \param hdmatableL table with windows effect on the left/right for both windows
*/
void setModeHdmaWindow1And2SingleHdma(u8 bgrnd, u8 bgrndmask,u8* hdmatable);

//---------------------------------------------------------------------------------
int main(void)
{
    // Copy tiles to VRAM
    bgInitTileSet(0, &patternsbg1, &palettebg1, 0, (&patternsbg1_end - &patternsbg1), 16*1*2, BG_16COLORS, 0x4000);
    bgInitTileSet(1, &patternsbg2, &palettebg2, 1, (&patternsbg2_end - &patternsbg2), 16*1*2, BG_16COLORS, 0x6000);

    // Copy Map to VRAM
    bgInitMapSet(0, &mapbg1, (&mapbg1_end - &mapbg1), SC_32x32, 0x0000);
	bgInitMapSet(1, &mapbg2, (&mapbg2_end - &mapbg2), SC_32x32, 0x1000);

    // Init Sprites gfx and palette with default size of 32x32
    oamInitGfxSet(&gfxpsrite, (&gfxpsrite_end - &gfxpsrite), &palsprite, (&palsprite_end - &palsprite), 0, 0x2000, OBJ_SIZE32_L64);

    // Define sprites parameters
    oamSet(0, p1_pos_x, p1_pos_y, 3, 0, 0, 0, 0); // Put sprite in 100,100, with maximum priority 3 from tile entry 0, palette 0
    oamSetEx(0, OBJ_SMALL, OBJ_SHOW);
    oamSet(4, p2_pos_x, p2_pos_y, 3, 0, 0, 0, 0); // Put sprite in 100,100, with maximum priority 3 from tile entry 0, palette 0
    oamSetEx(4, OBJ_SMALL, OBJ_SHOW);

    // Now Put in 16 color mode and disable other BGs except 1st and 2nd one
    setMode(BG_MODE1, 0);
    bgSetEnable(1);	// Enable BG2
    bgSetDisable(2);	// Disable BG3


	// FIXME PR to PVSNESLib ?? wrong shift
	#define FIXED_MSWIN2_BG2MSKOUT        (1 << 6) /*!< \brief Window 2 area BG2 inside (0) outside(1) */
	#define FIXED_MSWIN2_BG2MSKENABLE     (2 << 6) /*!< \brief Window 2 area BG2 enable */

	WaitForVBlank();
	// TODO Separate bg/window setup and hdma?
	setModeHdmaWindow1And2SingleHdma(0x03, 0xc3, (u8 *) &window_positions_table);

	setScreenOn();

	consoleNocashMessage("Go\n");

	// Wait for nothing :P
    while (1)
    {
		bool playersMoved = false;

        // Get current #0 pad
        pad0 = padsCurrent(0);

		// Handle player 1 movements
		if (pad0 & KEY_DOWN) {
			p1_pos_y += 10;
			if (p1_pos_y > 240) {
				p1_pos_y = 0;
			}
			oamSet(0, p1_pos_x, p1_pos_y, 3, 0, 0, 0, 0);
			playersMoved = true;
		}
		if (pad0 & KEY_UP) {
			p1_pos_y -= 10;
			if (p1_pos_y > 240) {
				p1_pos_y = 240;
			}
			oamSet(0, p1_pos_x, p1_pos_y, 3, 0, 0, 0, 0);
			playersMoved = true;
		}
		if (pad0 & KEY_RIGHT) {
			p1_pos_x += 10;
			oamSet(0, p1_pos_x, p1_pos_y, 3, 0, 0, 0, 0);
			playersMoved = true;
		}
		if (pad0 & KEY_LEFT) {
			p1_pos_x -= 10;
			oamSet(0, p1_pos_x, p1_pos_y, 3, 0, 0, 0, 0);
			playersMoved = true;
		}

        // Get current #1 pad
        pad1 = padsCurrent(1);

		// Handle player 2 movements
		if (pad1 & KEY_DOWN) {
			p2_pos_y += 10;
			if (p2_pos_y > 240) {
				p2_pos_y = 0;
			}
			oamSet(4, p2_pos_x, p2_pos_y, 3, 0, 0, 0, 0);
			playersMoved = true;
		}
		if (pad1 & KEY_UP) {
			p2_pos_y -= 10;
			if (p2_pos_y > 240) {
				p2_pos_y = 240;
			}
			oamSet(4, p2_pos_x, p2_pos_y, 3, 0, 0, 0, 0);
			playersMoved = true;
		}
		if (pad1 & KEY_RIGHT) {
			p2_pos_x += 10;
			oamSet(4, p2_pos_x, p2_pos_y, 3, 0, 0, 0, 0);
			playersMoved = true;
		}
		if (pad1 & KEY_LEFT) {
			p2_pos_x -= 10;
			oamSet(4, p2_pos_x, p2_pos_y, 3, 0, 0, 0, 0);
			playersMoved = true;
		}


		// Wait vblank sync
        WaitForVBlank();

		if (playersMoved) {
			
			// TODO Compute slope from players position difference ?
			// slope = (255*(x2-x1)) / (y2-y1)
			// direction of slope (sign) : sign(x2-x1) * sign(y2-y1) ?

			// TODO Use hardware division !!!
			// TODO Use unsigned ??
			consoleNocashMessage("Voronoi p1(%d,%d) p2(%d,%d)\n", p1_pos_x, p1_pos_y, p2_pos_x, p2_pos_y);
			s16 dy = (p2_pos_y - p1_pos_y);
			s16 dx = (p2_pos_x - p1_pos_x);
			// FIXME if dy == 0 --> slope is 0 and window is half-screen (top / right)
			s16 slope = - ((((dy << 5)) / dx) << 3);	// Works up to dy == 1023 ? TODO Could remove to bits to both dy and dx too ?
			consoleNocashMessage("Voronoi dx=%d dy=%d slope = %d\n", dx, dy, slope);

			// TODO Hardware division !!!
			// TODO Handle slope == 0
			u16 abs_slope = slope < 0 ? -slope : slope;
			u16 lines = (255<<8)/abs_slope;
			u16 columns = abs_slope > 240 ? 256 : abs_slope;
			consoleNocashMessage("Voronoi split lines=%d columns=%d\n", lines, columns);
			u16 offset_x = columns < 256 ? 128 - (columns >> 1) : 0;	// FIXME wrong with positive slope ??
			u16 offset_y = lines < 240 ? 120 - (lines >> 1) : 0;	// FIXME offset hdma --> need to handle full-height hdma with 4 streaks of 60 lines ?
			consoleNocashMessage("Voronoi hdma offsets x=%d y=%d\n", offset_x, offset_y);
			u16 split_x = slope == 0
				? (128 << 8)
				: (slope > 0 ? (offset_x << 8) : ((255 - offset_x) << 8));
			consoleNocashMessage("Voronoi starting at X = 0x%04x\n", split_x);
			u16 table_offset = 5;
			u8 y;

			// FIXME if dy == 0 --> slope is 0 and window is half-screen (top / right) --> handle special case ?!

			for (y=0; y<240; y++) {
				if ((y%60) == 0) {
					table_offset++;
				}
				u8 split = split_x >> 8;
				// TODO advance ptr instead of multiplications every time
				if (dx > 0) {
					*(window_positions_table+table_offset+y*4) = 0;			// Window 1 Left
					*(window_positions_table+table_offset+y*4+1) = split;		// Window 1 Right
					*(window_positions_table+table_offset+y*4+2) = split;		// Window 2 Left
					*(window_positions_table+table_offset+y*4+3) = 255;		// Window 2 Right
				} else {
					*(window_positions_table+table_offset+y*4) = split;			// Window 1 Left
					*(window_positions_table+table_offset+y*4+1) = 255;		// Window 1 Right
					*(window_positions_table+table_offset+y*4+2) = 0;		// Window 2 Left
					*(window_positions_table+table_offset+y*4+3) = split;		// Window 2 Right
				}
				if (y >= offset_y && y < (240-offset_y)) {
					split_x += slope;
				}
				if (y >= (240-offset_y)) {
					split_x = (slope > 0) ? (255 << 8) : 0;
				}
			}
		}

		// TODO Compute players distance + scroll backgrounds + voronoi split ?

		// TODO During VBlank or use double buffer?
    }
    return 0;
}