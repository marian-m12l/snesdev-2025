#include <snes.h>
#include <string.h>

#define SCREEN_WIDTH (256)
#define SCREEN_HALF_WIDTH (128)
#define SCREEN_HEIGHT (224)
#define SCREEN_HALF_HEIGHT (112)

#define MAP_WIDTH (512)
#define MAP_HEIGHT (512)

#define SPRITE_WIDTH (32)
#define SPRITE_HEIGHT (32)
#define SPRITE_HALF_WIDTH (16)
#define SPRITE_HALF_HEIGHT (16)

#define MOVEMENT_STEP (8)

#define HDMA_EFFECT_SINGLE_WINDOW (1)
#define HDMA_EFFECT_DUAL_WINDOWS (2)

extern const char patternsmap_512_512, patternsmap_512_512_end;
extern const char palettemap_512_512, palettemap_512_512_end;
extern const char map_512_512, map_512_512_end;

extern const char gfxpsrite, gfxpsrite_end;
extern const char palsprite, palsprite_end;

u16 p1_pos_x = 64;
u16 p1_pos_y = 120;
u16 p2_pos_x = 192;
u16 p2_pos_y = 120;
bool playersMoved = true;	// We want to sprite positions and bg scroll to be adjusted on the first frame

// Default effect uses a single window (no visible separator for split-screen)
u8 hdmaEffect = HDMA_EFFECT_SINGLE_WINDOW;
bool hdmaChanged = true;	// We want hdma to be setup on the first frame

// LUTs contain the X/Y camera displacement for a given player-to-player X/Y distance (in a 128*128 frame vs 512*512 BG)
extern const u16 camera_lut_lo[64][128];
extern const u16 camera_lut_hi[64][128];


// HDMA_EFFECT_SINGLE_WINDOW

// Single HDMA table for windows 1's left/right positions
// HDMA Mode 1 : 2 bytes transfered at once on 2 consecutive registers ($2126-$2127)
u8 window1_positions_table[] = {
	// Lines count, Window 1 Left, Window 1 Right
	1, 0xff, 0x0,	// Disabled at first

	0x80 | 64,					// 64 lines

	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,

	0x80 | 64,					// 64 lines

	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,

	0x80 | 64,					// 64 lines

	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,

	0x80 | 32,					// 32 lines

	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	
	1, 0xff, 0x0,
	0
};

void setModeHdmaWindow1SingleHdma(u8 bgrnd, u8 bgrndmask,u8* hdmatable);


// HDMA_EFFECT_DUAL_WINDOWS

// Single HDMA table for both windows's left/right positions
// HDMA Mode 4 : 4 bytes transfered at once on 4 consecutive registers ($2126-$2129)
u8 window_positions_table[] = {
	// Lines count, Window 1 Left, Window 1 Right, Window 2 Left, Window 2 Right
	1, 0xff, 0x0, 0xff, 0x0,	// Disabled at first

	0x80 | 64,					// 64 lines

	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,

	0x80 | 64,					// 64 lines

	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,

	0x80 | 64,					// 64 lines

	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,

	0x80 | 32,					// 32 lines

	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0,
	
	1, 0xff, 0x0, 0xff, 0x0,
	0
};

void setModeHdmaWindow1And2SingleHdma(u8 bgrnd, u8 bgrndmask,u8* hdmatable);


//---------------------------------------------------------------------------------
int main(void) {
	// Copy tiles to VRAM (shared tiles for both background maps)
	// VRAM address is 4K-aligned word-address (8KiB chunk)
	// Background tiles @ 0x0000-0x2000
    bgInitTileSet(0, &patternsmap_512_512, &palettemap_512_512, 0, (&patternsmap_512_512_end - &patternsmap_512_512), 16 * 2, BG_16COLORS, 0x0000);
	bgSetGfxPtr(1, 0x0000);
	
	// Copy Map to VRAM
	// Background tilemap @ 0x2000-0x4000
    bgInitMapSet(0, &map_512_512, (&map_512_512_end - &map_512_512), SC_64x64, 0x2000);
    bgInitMapSet(1, &map_512_512, (&map_512_512_end - &map_512_512), SC_64x64, 0x3000);

    // Init Sprites gfx and palette with default size of 32x32
	// VRAM address is 8K-aligned word-address (16KiB chunk)
	// Sprite tiles @ 0x6000-0x8000
    oamInitGfxSet(&gfxpsrite, (&gfxpsrite_end - &gfxpsrite), &palsprite, (&palsprite_end - &palsprite), 0, 0x6000, OBJ_SIZE32_L64);

    // Define sprites parameters
    oamSet(0, p1_pos_x, p1_pos_y, 3, 0, 0, 0, 0); // Put sprite in 100,100, with maximum priority 3 from tile entry 0, palette 0
    oamSetEx(0, OBJ_SMALL, OBJ_SHOW);
    oamSet(4, p2_pos_x, p2_pos_y, 3, 0, 0, 4, 0); // Put sprite in 100,100, with maximum priority 3 from tile entry 0, palette 0
    oamSetEx(4, OBJ_SMALL, OBJ_SHOW);
    oamSet(8, SCREEN_HALF_WIDTH - SPRITE_HALF_WIDTH, SCREEN_HALF_HEIGHT - SPRITE_HALF_HEIGHT, 3, 0, 0, 8, 0); // Put sprite in 100,100, with maximum priority 3 from tile entry 0, palette 0
    oamSetEx(8, OBJ_SMALL, OBJ_HIDE);

    // Now Put in 16 color mode and disable other BGs except 1st and 2nd one
    setMode(BG_MODE1, 0);
    bgSetEnable(1);	// Enable BG2
    bgSetDisable(2);	// Disable BG3
	
	WaitForVBlank();
	setScreenOn();
	consoleNocashMessage("Go\n");

	while (1) {
		// Handle player 1 movements
		u16 pad0 = padsCurrent(0);
		if (pad0 & KEY_DOWN) {
			p1_pos_y += MOVEMENT_STEP;
			if (p1_pos_y > (MAP_HEIGHT - SPRITE_HEIGHT)) {
				p1_pos_y = MAP_HEIGHT - SPRITE_HEIGHT;
			}
			playersMoved = true;
		}
		if (pad0 & KEY_UP) {
			p1_pos_y -= MOVEMENT_STEP;
			if (p1_pos_y > MAP_HEIGHT) {
				p1_pos_y = 0;
			}
			playersMoved = true;
		}
		if (pad0 & KEY_RIGHT) {
			p1_pos_x += MOVEMENT_STEP;
			if (p1_pos_x > (MAP_WIDTH - SPRITE_WIDTH)) {
				p1_pos_x = MAP_WIDTH - SPRITE_WIDTH;
			}
			playersMoved = true;
		}
		if (pad0 & KEY_LEFT) {
			p1_pos_x -= MOVEMENT_STEP;
			if (p1_pos_x > MAP_WIDTH) {
				p1_pos_x = 0;
			}
			playersMoved = true;
		}
		// Button press switches HDMA mode
		u16 pad0_pressed = padsDown(0);
		if (pad0_pressed & (KEY_A | KEY_B | KEY_X | KEY_Y | KEY_L | KEY_R)) {
			if (hdmaEffect == HDMA_EFFECT_SINGLE_WINDOW) {
				hdmaEffect = HDMA_EFFECT_DUAL_WINDOWS;
			} else {
				hdmaEffect = HDMA_EFFECT_SINGLE_WINDOW;
			}
			hdmaChanged = true;
		}

		// Handle player 2 movements
        u16 pad1 = padsCurrent(1);
		if (pad1 & KEY_DOWN) {
			p2_pos_y += MOVEMENT_STEP;
			if (p2_pos_y > (MAP_HEIGHT - SPRITE_HEIGHT)) {
				p2_pos_y = MAP_HEIGHT - SPRITE_HEIGHT;
			}
			playersMoved = true;
		}
		if (pad1 & KEY_UP) {
			p2_pos_y -= MOVEMENT_STEP;
			if (p2_pos_y > MAP_HEIGHT) {
				p2_pos_y = 0;
			}
			playersMoved = true;
		}
		if (pad1 & KEY_RIGHT) {
			p2_pos_x += MOVEMENT_STEP;
			if (p2_pos_x > (MAP_WIDTH - SPRITE_WIDTH)) {
				p2_pos_x = MAP_WIDTH - SPRITE_WIDTH;
			}
			playersMoved = true;
		}
		if (pad1 & KEY_LEFT) {
			p2_pos_x -= MOVEMENT_STEP;
			if (p2_pos_x > MAP_WIDTH) {
				p2_pos_x = 0;
			}
			playersMoved = true;
		}
		// Button press switches HDMA mode
		u16 pad1_pressed = padsDown(1);
		if (pad1_pressed & (KEY_A | KEY_B | KEY_X | KEY_Y | KEY_L | KEY_R)) {
			if (hdmaEffect == HDMA_EFFECT_SINGLE_WINDOW) {
				hdmaEffect = HDMA_EFFECT_DUAL_WINDOWS;
			} else {
				hdmaEffect = HDMA_EFFECT_SINGLE_WINDOW;
			}
			hdmaChanged = true;
		}
		
		// Adjust "camera" position (bg scroll and sprite positions)
		if (playersMoved || hdmaChanged) {
			// Compute H/V distances between players
			s16 dy = (p2_pos_y - p1_pos_y);
			s16 dx = (p2_pos_x - p1_pos_x);

			// Absolute distances
			u16 abs_dx = dx >= 0 ? dx : -(dx+1)+1;
			u16 abs_dy = dy >= 0 ? dy : -(dy+1)+1;

			// Get "camera" H/V offsets from LUT
			// Indexes and values are in a 128*128 frame
			u16 lut_w = abs_dx >> 2;
			u16 camera_diff = lut_w < 64 ? camera_lut_lo[lut_w][abs_dy>>2] : camera_lut_hi[lut_w-64][abs_dy>>2];

			// New scroll values to be calculated
			u16 bg1_scroll_x, bg1_scroll_y, bg2_scroll_x, bg2_scroll_y;

			// Defaults to displaying Window 1 / BG 1 only
			s16 slope = 0;
			u16 split_x = 255 << 8;
			u16 offset_y = 0;

			// Both player are displayed on the same "camera" / BG --> no split-screen
			// (when they are close enough)
			if (camera_diff == 0) {
				// Compute middle point between players
				u16 camera_x = (p1_pos_x + p2_pos_x) >> 1;
				u16 camera_y = (p1_pos_y + p2_pos_y) >> 1;

				// Scroll backgrounds to be centered on the midpoint
				bg1_scroll_x = camera_x + SPRITE_HALF_WIDTH;
				bg1_scroll_y = camera_y + SPRITE_HALF_HEIGHT;
				bg2_scroll_x = bg1_scroll_x;
				bg2_scroll_y = bg1_scroll_y;

				// Hide crosshair
				oamSetVisible(8, OBJ_HIDE);
			} else {
				// Split-screen

				// Extract H/V components of "camera" offset (in the 512*512 screen space)
				// This is the total distance between the 2 backgrounds
				u16 diff_x_camera = (camera_diff >> 8) << 2;
				u16 diff_y_camera = (camera_diff & 0xff) << 2;
				
				// Signed distance between each player and the center of its background
				s16 half_diff_x = dx < 0 ? -(diff_x_camera >> 1) : (diff_x_camera >> 1);
				s16 half_diff_y = dy < 0 ? -(diff_y_camera >> 1) : (diff_y_camera >> 1);
				bg1_scroll_x = p1_pos_x + half_diff_x + SPRITE_HALF_WIDTH;
				bg1_scroll_y = p1_pos_y + half_diff_y + SPRITE_HALF_HEIGHT;
				bg2_scroll_x = p2_pos_x - half_diff_x + SPRITE_HALF_WIDTH;
				bg2_scroll_y = p2_pos_y - half_diff_y + SPRITE_HALF_HEIGHT;

				// Display crosshair in the center of the screen
				oamSetVisible(8, OBJ_SHOW);
				oamSetXY(8, SCREEN_HALF_WIDTH - SPRITE_HALF_WIDTH, SCREEN_HALF_HEIGHT - SPRITE_HALF_HEIGHT);

				// Compute the "slope" of the split-screen separator (low value means a horizontal-ish split separator,
				// high value means a vertical-ish separator)
				// Hackish way to run a hardware division --> TODO use a proper asm routine?
				*((u16*) 0x4204) = abs_dy << 4;
				*((u8*) 0x4206) = abs_dx >> 1;	// FIXME limit dx to 8 bits !!! FIXME handle dx == 0 !!
				// TODO wait 16 cycles before reading division result?
				s16 s_slope = ((dx >= 0 && dy >= 0) || (dx < 0 && dy < 0)) ? -((*((u16*) 0x4214)) << 3) : ((*((u16*) 0x4214)) << 3);

				slope = s_slope;
				//consoleNocashMessage("|dx|=%d |dy|=%d u_slope=%d s_slope=%d slope=%d\n", abs_dx, abs_dy, u_slope, s_slope, slope);

				// TODO Handle slope == 0
				u16 abs_slope = slope < 0 ? -slope : slope;
				
				// Compute the height of the split separator (in lines) in order to vertically center the separator
				// Hackish way to run a hardware division --> TODO use a proper asm routine?
				*((u16*) 0x4204) = abs_slope > 255 ? 0x0fff : 0xffff;
				*((u8*) 0x4206) = abs_slope > 255 ? (abs_slope >> 4) : abs_slope;	// FIXME limit dx to 8 bits !!! FIXME handle abs_slope == 0 !!
				// TODO wait 16 cycles before reading division result?
				// Compute the width of the split separator (in columns) in order to horizontally center the separator
				u16 columns = abs_slope > 292 ? SCREEN_WIDTH : (abs_slope * SCREEN_HEIGHT) >> 8;
				u16 offset_x = columns < SCREEN_WIDTH ? SCREEN_HALF_WIDTH - (columns >> 1) : 0;	// How far from the left border does the separator start?
				u16 lines = *((u16*) 0x4214);
				offset_y = lines < SCREEN_HEIGHT ? SCREEN_HALF_HEIGHT - (lines >> 1) : 0;	// How far from the top border does the separator start?
				//consoleNocashMessage("Voronoi split lines=%d columns=%d\n", lines, columns);
				//consoleNocashMessage("Voronoi hdma offsets x=%d y=%d\n", offset_x, offset_y);

				// Compute the starting X position of the split-screen separator on the top of the screen
				split_x = slope == 0
					? (SCREEN_HALF_WIDTH << 8)
					: (slope > 0 ? (offset_x << 8) : ((255 - offset_x) << 8));
				//consoleNocashMessage("Voronoi starting at X = 0x%04x\n", split_x);
			}

			// Clamp bg scroll
			// bg_scroll = camera position - half-screen (scroll is top-left)
			bg1_scroll_x = bg1_scroll_x < SCREEN_HALF_WIDTH ? 0 : (bg1_scroll_x > (MAP_WIDTH - SCREEN_HALF_WIDTH) ? (MAP_WIDTH - SCREEN_WIDTH) : bg1_scroll_x - SCREEN_HALF_WIDTH);
			bg1_scroll_y = bg1_scroll_y < SCREEN_HALF_HEIGHT ? 0 : (bg1_scroll_y > (MAP_HEIGHT - SCREEN_HALF_HEIGHT) ? (MAP_HEIGHT - SCREEN_HEIGHT) : bg1_scroll_y - SCREEN_HALF_HEIGHT);
			bg2_scroll_x = bg2_scroll_x < SCREEN_HALF_WIDTH ? 0 : (bg2_scroll_x > (MAP_WIDTH - SCREEN_HALF_WIDTH) ? (MAP_WIDTH - SCREEN_WIDTH) : bg2_scroll_x - SCREEN_HALF_WIDTH);
			bg2_scroll_y = bg2_scroll_y < SCREEN_HALF_HEIGHT ? 0 : (bg2_scroll_y > (MAP_HEIGHT - SCREEN_HALF_HEIGHT) ? (MAP_HEIGHT - SCREEN_HEIGHT) : bg2_scroll_y - SCREEN_HALF_HEIGHT);
			
			// Compute sprites on-screen position
			u16 p1_sprite_x = p1_pos_x - bg1_scroll_x;
			u16 p1_sprite_y = p1_pos_y - bg1_scroll_y;
			u16 p2_sprite_x = p2_pos_x - bg2_scroll_x;
			u16 p2_sprite_y = p2_pos_y - bg2_scroll_y;
			//consoleNocashMessage("dx=%d dy=%d len=%d dist=%d dxn=%d dyn=%d dxc=%d dyc=%d scx1=%d scy1=%d scx2=%d scy2=%d\n", dx, dy, length, distance, diff_x_normalized, diff_y_normalized, diff_x_camera, diff_y_camera, bg1_scroll_x, bg1_scroll_y, bg2_scroll_x, bg2_scroll_y);
			//consoleNocashMessage("dx=%d dy=%d dc=0x%04x dxc=%d dyc=%d scx1=%d scy1=%d scx2=%d scy2=%d p1x=%d p1y=%d p2x=%d p2y=%d\n", dx, dy, camera_diff, diff_x_camera, diff_y_camera, bg1_scroll_x, bg1_scroll_y, bg2_scroll_x, bg2_scroll_y, p1_sprite_x, p1_sprite_y, p2_sprite_x, p2_sprite_y);

			// Apply sprite positions
			oamSetXY(0, p1_sprite_x, p1_sprite_y);
			oamSetXY(4, p2_sprite_x, p2_sprite_y);

			// Wait vblank sync
			WaitForVBlank();

			// Apply bg scroll
			bgSetScroll(0, bg1_scroll_x, bg1_scroll_y);
			bgSetScroll(1, bg2_scroll_x, bg2_scroll_y);

			// Update HDMA table
			if (hdmaEffect == HDMA_EFFECT_SINGLE_WINDOW) {
				u8* ptr = window1_positions_table + 3;
				u8 split = split_x >> 8;
				u8 y;
				for (y=0; y<SCREEN_HEIGHT; y++) {
					if ((y & 0x3f) == 0) {	// Avoid modulo / division by using binary mask?
						ptr++;
					}
					if (dx >= 0) {	// Window/BG1 to the left
						if (split == 0) { // Hide Window/BG1 altogether
							*(ptr++) = 255;			// Window Left
							*(ptr++) = 0;		// Window Right
						} else {
							*(ptr++) = 0;			// Window Left
							*(ptr++) = split;		// Window Right
						}
					} else {	// Window/BG1 to the right
						if (split == 255) {	// Hide Window/BG1 altogether
							*(ptr++) = 255;		// Window Left
							*(ptr++) = 0;			// Window Right
						} else {
							*(ptr++) = split;		// Window Left
							*(ptr++) = 255;			// Window Right
						}
					}
					if (y >= offset_y && y < (SCREEN_HEIGHT-offset_y)) {
						split_x += slope;
						split = split_x >> 8;
					}
					if (y >= (SCREEN_HEIGHT-offset_y)) {
						split_x = (slope > 0) ? (255 << 8) : 0;
						split = split_x >> 8;
					}
				}
			} else {	// HDMA_EFFECT_DUAL_WINDOWS
				u8* ptr = window_positions_table + 5;
				u8 split = split_x >> 8;
				u8 y;
				for (y=0; y<SCREEN_HEIGHT; y++) {
					if ((y & 0x3f) == 0) {	// Avoid modulo / division by using binary mask?
						ptr++;
					}
					if (dx >= 0) {	// Window/BG1 to the left
						if (split == 0) { // Hide Window/BG1 altogether
							*(ptr++) = 255;		// Window 1 Left
							*(ptr++) = 0;		// Window 1 Right
							*(ptr++) = 0;		// Window 2 Left
							*(ptr++) = 255;		// Window 2 Right
						} else if (split == 255) { // Hide Window/BG2 altogether
							*(ptr++) = 0;		// Window 1 Left
							*(ptr++) = 255;		// Window 1 Right
							*(ptr++) = 255;		// Window 2 Left
							*(ptr++) = 0;		// Window 2 Right
						} else {
							*(ptr++) = 0;		// Window 1 Left
							*(ptr++) = split-1;	// Window 1 Right
							*(ptr++) = split+1;	// Window 2 Left
							*(ptr++) = 255;		// Window 2 Right
						}
					} else {	// Window/BG1 to the right
						if (split == 255) {	// Hide Window/BG1 altogether
							*(ptr++) = 255;		// Window 1 Left
							*(ptr++) = 0;		// Window 1 Right
							*(ptr++) = 0;		// Window 2 Left
							*(ptr++) = 255;		// Window 2 Right
						} else if (split == 0) {	// Hide Window/BG2 altogether
							*(ptr++) = 0;		// Window 1 Left
							*(ptr++) = 255;		// Window 1 Right
							*(ptr++) = 255;		// Window 2 Left
							*(ptr++) = 0;		// Window 2 Right
						} else {
							*(ptr++) = split+1;		// Window 1 Left
							*(ptr++) = 255;			// Window 1 Right
							*(ptr++) = 0;			// Window 2 Left
							*(ptr++) = split-1;		// Window 2 Right
						}
					}
					if (y >= offset_y && y < (SCREEN_HEIGHT-offset_y)) {
						split_x += slope;
						split = split_x >> 8;
					}
					if (y >= (SCREEN_HEIGHT-offset_y)) {
						split_x = (slope > 0) ? (255 << 8) : 0;
						split = split_x >> 8;
					}
				}
			}

			// Change HDMA config if needed
			if (hdmaChanged) {
				setModeHdmaWindowReset(1 << 2);	// Stop HDMA channel 2
				if (hdmaEffect == HDMA_EFFECT_SINGLE_WINDOW) {
					setModeHdmaWindow1SingleHdma(0x01, 0x03, window1_positions_table);
				} else {	// HDMA_EFFECT_DUAL_WINDOWS
					setModeHdmaWindow1And2SingleHdma(0x03, 0xc3, window_positions_table);
				}
				hdmaChanged = false;
			}

			playersMoved = false;
		} else {
			WaitForVBlank();
		}
    }
    return 0;
}